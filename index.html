<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>A4 - Linked Views</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
      :root {
        --bg: #f6f7f9;
        --card: #fff;
        --ink: #111827;
        --muted: #6b7280;
        --line: #e5e7eb;
        --shadow: 0 8px 28px rgba(0, 0, 0, 0.08);
        --radius: 14px;
      }
      body {
        margin: 0;
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Arial,
          sans-serif;
        background: var(--bg);
        color: var(--ink);
      }
      header {
        position: sticky;
        top: 0;
        z-index: 10;
        background: rgba(246, 247, 249, 0.92);
        backdrop-filter: blur(6px);
        border-bottom: 1px solid var(--line);
        padding: 12px 18px;
      }
      h1 {
        margin: 0;
        font-size: 18px;
        font-weight: 650;
      }
      .wrap {
        max-width: 1200px;
        margin: 16px auto;
        padding: 0 18px 28px 18px;
        display: grid;
        grid-template-columns: 320px 1fr;
        gap: 14px;
      }
      .card {
        background: var(--card);
        border: 1px solid var(--line);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
      }
      .card h2 {
        font-size: 14px;
        margin: 0;
        padding: 12px;
        border-bottom: 1px solid var(--line);
        font-weight: 650;
      }
      .content {
        padding: 12px;
      }

      input[type="search"] {
        width: 100%;
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--line);
        outline: none;
        font-size: 13px;
      }
      .btnrow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }
      button {
        padding: 8px 10px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: #fff;
        cursor: pointer;
        font-size: 12px;
      }
      button:hover {
        filter: brightness(0.98);
      }

      .states {
        border: 1px solid var(--line);
        border-radius: 12px;
        padding: 10px;
        max-height: 520px;
        overflow: auto;
        margin-top: 10px;
      }
      .state-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 6px 6px;
        border-radius: 10px;
      }
      .state-item:hover {
        background: #f3f4f6;
      }
      .state-item label {
        cursor: pointer;
        font-size: 13px;
        width: 100%;
        display: flex;
        justify-content: space-between;
        gap: 10px;
      }
      .badge {
        color: var(--muted);
        font-size: 12px;
        font-variant-numeric: tabular-nums;
      }

      .views {
        display: grid;
        grid-template-columns: 1.35fr 0.65fr;
        gap: 14px;
      }
      .empty {
        padding: 14px;
        border: 1px dashed var(--line);
        border-radius: 12px;
        color: var(--muted);
        font-size: 13px;
        background: #fafafa;
        line-height: 1.4;
      }

      .axis text {
        font-size: 11px;
        fill: #374151;
      }
      .axis path,
      .axis line {
        stroke: #d1d5db;
      }

      .pt {
        cursor: pointer;
      }
      .pt.dim {
        opacity: 0.12;
      }
      .pt.active {
        stroke-width: 2.5px;
        opacity: 0.95;
      }

      .selection {
        fill-opacity: 0.12;
      }
      .handle {
        display: none;
      }

      .seg {
        cursor: pointer;
      }
      .seg.dim {
        opacity: 0.2;
      }

      .meta {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
        margin-top: 8px;
      }

      .legend {
        display: flex;
        flex-wrap: wrap;
        gap: 10px 12px;
        margin-top: 10px;
        color: var(--muted);
        font-size: 12px;
      }
      .leg-item {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .swatch {
        width: 10px;
        height: 10px;
        border-radius: 3px;
        border: 1px solid rgba(0, 0, 0, 0.15);
        flex: 0 0 auto;
      }

      .tooltip {
        position: fixed;
        pointer-events: none;
        background: rgba(17, 24, 39, 0.92);
        color: #fff;
        padding: 10px 10px;
        border-radius: 10px;
        font-size: 12px;
        line-height: 1.35;
        max-width: 340px;
        transform: translate(10px, 10px);
        display: none;
        z-index: 999;
      }
      .k {
        color: rgba(255, 255, 255, 0.7);
      }
      .kv {
        font-variant-numeric: tabular-nums;
      }

      @media (max-width: 980px) {
        .wrap {
          grid-template-columns: 1fr;
        }
        .views {
          grid-template-columns: 1fr;
        }
        .states {
          max-height: 240px;
        }
      }
    </style>
  </head>

  <body>
    <header>
      <h1>Poverty vs Unemployment + Education</h1>
    </header>

    <div class="wrap">
      <aside class="card">
        <h2>States</h2>
        <div class="content">
          <input
            id="stateSearch"
            type="search"
            placeholder="Search (MA, Texas)..."
          />
          <div class="btnrow">
            <button id="btnSelectAll">Select All</button>
            <button id="btnClearAll">Clear</button>
            <button id="btnClearBrush">Clear Brush</button>
          </div>
          <div id="statesBox" class="States"></div>
        </div>
      </aside>

      <main class="card">
        <h2>Linked Views</h2>
        <div class="content">
          <div id="emptyMsg" class="empty">
            Select one or more states to show the views.
          </div>

          <div id="views" class="views" style="display: none">
            <div class="card" style="box-shadow: none">
              <h2 style="border-bottom: 1px solid var(--line)">Scatter</h2>
              <div class="content">
                <svg id="scatter" width="100%" height="460"></svg>
                <div id="legend" class="legend"></div>
                <div id="scatterNote" class="meta"></div>
              </div>
            </div>

            <div class="card" style="box-shadow: none">
              <h2 style="border-bottom: 1px solid var(--line)">
                Education (100%)
              </h2>
              <div class="content">
                <svg id="stacked" width="100%" height="360"></svg>
                <div id="stackMeta" class="meta"></div>
                <div id="details" class="meta" style="margin-top: 10px"></div>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>

    <div id="tooltip" class="tooltip"></div>

    <script>
      (async function () {
        const DATA_PATH = "data/merged_county_edu_unemp_poverty.csv";
        const tooltip = d3.select("#tooltip");

        let data = [];
        let filtered = [];
        let selectedStates = new Set();
        let brushedFips = new Set();
        let activeCountyFips = null;
        let activeSegmentKey = null;

        const EDU = [
          { key: "edu_not_hs_pct_2019_23", label: "Not HS" },
          { key: "edu_hs_grad_pct_2019_23", label: "HS" },
          { key: "edu_some_college_pct_2019_23", label: "Some College/AA" },
          { key: "edu_bachelors_plus_pct_2019_23", label: "Bachelor's+" },
        ];

        const toNum = (v) =>
          v === null || v === "" || typeof v === "undefined" ? NaN : +v;

        data = await d3.csv(DATA_PATH, d3.autoType);

        data.forEach((d) => {
          d.poverty_rate_2023 = toNum(d.poverty_rate_2023);
          d.unemployment_rate_2023 = toNum(d.unemployment_rate_2023);
          d.labor_force_2023 = toNum(d.labor_force_2023);
          d.median_household_income_2022 = toNum(
            d.median_household_income_2022,
          );
          EDU.forEach((k) => (d[k.key] = toNum(d[k.key])));
        });

        const stateCounts = d3.rollup(
          data,
          (v) => v.length,
          (d) => d.State,
        );
        const states = Array.from(stateCounts.keys()).sort(d3.ascending);

        const scatterSvg = d3.select("#scatter");
        const stackSvg = d3.select("#stacked");

        function getSvgSize(svgSel, fallbackW, fallbackH) {
          const node = svgSel.node();
          const rect = node.getBoundingClientRect();
          const w = rect.width || fallbackW;
          const h = +svgSel.attr("height") || fallbackH;
          return { w, h };
        }

        const scatter = {
          margin: { top: 28, right: 18, bottom: 42, left: 52 },
          x: d3.scaleLinear(),
          y: d3.scaleLinear(),
          r: d3.scaleSqrt().range([2.5, 9]),
          g: scatterSvg.append("g"),
          gx: scatterSvg.append("g").attr("class", "axis"),
          gy: scatterSvg.append("g").attr("class", "axis"),
          brushG: scatterSvg.append("g").attr("class", "brush"),
        };

        const stacked = {
          margin: { top: 18, right: 18, bottom: 26, left: 44 },
          g: stackSvg.append("g"),
          x: d3.scaleBand().padding(0.25),
          y: d3.scaleLinear(),
        };

        const brush = d3.brush().on("start brush end", brushed);
        scatter.brushG.call(brush);

        buildStateCheckboxes(states, stateCounts);

        d3.select("#btnSelectAll").on("click", () => {
          selectedStates = new Set(states);
          updateCheckboxUI();
          onStateSelectionChanged();
        });

        d3.select("#btnClearAll").on("click", () => {
          selectedStates = new Set();
          updateCheckboxUI();
          onStateSelectionChanged();
        });

        d3.select("#btnClearBrush").on("click", () => clearBrushAndActive());

        d3.select("#stateSearch").on("input", function () {
          const q = this.value.trim().toLowerCase();
          d3.selectAll(".state-item").style("display", (d) => {
            const s = (d || "").toLowerCase();
            return s.includes(q) ? null : "none";
          });
        });

        window.addEventListener("resize", () => {
          if (selectedStates.size > 0) renderAll();
        });

        function buildStateCheckboxes(states, counts) {
          const box = d3.select("#statesBox");

          box
            .selectAll("div.state-item")
            .data(states, (d) => d)
            .join("div")
            .attr("class", "state-item")
            .each(function (state) {
              const row = d3.select(this);
              row.html("");

              row
                .append("input")
                .attr("type", "checkbox")
                .attr("id", `cb_${state}`)
                .on("change", function () {
                  if (this.checked) selectedStates.add(state);
                  else selectedStates.delete(state);
                  onStateSelectionChanged();
                });

              row
                .append("label")
                .attr("for", `cb_${state}`)
                .html(() => {
                  const c = counts.get(state) || 0;
                  return `<span>${state}</span><span class="badge">${c}</span>`;
                });

              row.datum(state);
            });
        }

        function updateCheckboxUI() {
          d3.selectAll("#statesBox input[type='checkbox']").each(function () {
            const st = this.id.replace("cb_", "");
            this.checked = selectedStates.has(st);
          });
        }

        function onStateSelectionChanged() {
          brushedFips = new Set();
          activeCountyFips = null;
          activeSegmentKey = null;

          if (selectedStates.size === 0) {
            d3.select("#views").style("display", "none");
            d3.select("#emptyMsg").style("display", "block");
            d3.select("#legend").html("");
            d3.select("#scatterNote").text("");
            return;
          }

          d3.select("#emptyMsg").style("display", "none");
          d3.select("#views").style("display", "grid");

          filtered = data.filter((d) => selectedStates.has(d.State));
          renderAll();
        }

        function clearBrushAndActive() {
          brushedFips = new Set();
          activeCountyFips = null;
          activeSegmentKey = null;
          scatter.brushG.call(brush.move, null);
          renderAll();
        }

        function renderAll() {
          renderScatter();
          renderLegend();
          renderStacked();
          renderDetails();
        }

        function makeColorScale() {
          const st = Array.from(selectedStates).sort(d3.ascending);
          return d3.scaleOrdinal(st, d3.schemeTableau10.concat(d3.schemeSet3));
        }

        function renderLegend() {
          const st = Array.from(selectedStates).sort(d3.ascending);
          const color = makeColorScale();

          const items = d3
            .select("#legend")
            .selectAll("div.leg-item")
            .data(st, (d) => d)
            .join("div")
            .attr("class", "leg-item");

          items
            .selectAll("span.swatch")
            .data((d) => [d])
            .join("span")
            .attr("class", "swatch")
            .style("background", (d) => color(d));

          items
            .selectAll("span.txt")
            .data((d) => [d])
            .join("span")
            .attr("class", "txt")
            .text((d) => d);
        }

        function renderScatter() {
          const { w, h } = getSvgSize(scatterSvg, 720, 460);
          const innerW = w - scatter.margin.left - scatter.margin.right;
          const innerH = h - scatter.margin.top - scatter.margin.bottom;

          scatter.g.attr(
            "transform",
            `translate(${scatter.margin.left},${scatter.margin.top})`,
          );
          scatter.gx.attr(
            "transform",
            `translate(${scatter.margin.left},${scatter.margin.top + innerH})`,
          );
          scatter.gy.attr(
            "transform",
            `translate(${scatter.margin.left},${scatter.margin.top})`,
          );

          const xKey = "poverty_rate_2023";
          const yKey = "unemployment_rate_2023";

          const fx = filtered.filter(
            (d) => Number.isFinite(d[xKey]) && Number.isFinite(d[yKey]),
          );

          const validByState = d3.rollup(
            fx,
            (v) => v.length,
            (d) => d.State,
          );
          const missingStates = Array.from(selectedStates).filter(
            (s) => (validByState.get(s) || 0) === 0,
          );

          d3.select("#scatterNote").text(
            missingStates.length
              ? `No valid points for: ${missingStates.join(", ")} (missing poverty/unemployment)`
              : "",
          );

          if (fx.length === 0) {
            scatter.g.selectAll("circle.pt").remove();
            scatter.x.domain([0, 1]).range([0, innerW]);
            scatter.y.domain([0, 1]).range([innerH, 0]);
            scatter.gx.call(d3.axisBottom(scatter.x).ticks(4));
            scatter.gy.call(d3.axisLeft(scatter.y).ticks(4));
            scatter.brushG.lower();
            return;
          }

          scatter.x
            .domain(d3.extent(fx, (d) => d[xKey]))
            .nice()
            .range([0, innerW]);
          scatter.y
            .domain(d3.extent(fx, (d) => d[yKey]))
            .nice()
            .range([innerH, 0]);
          scatter.r.domain(d3.extent(fx, (d) => d.labor_force_2023 || 0));

          scatter.gx.call(d3.axisBottom(scatter.x).ticks(6));
          scatter.gy.call(d3.axisLeft(scatter.y).ticks(6));

          scatterSvg
            .selectAll(".xlab")
            .data([0])
            .join("text")
            .attr("class", "xlab")
            .attr("x", scatter.margin.left + innerW / 2)
            .attr("y", scatter.margin.top + innerH + 36)
            .attr("text-anchor", "middle")
            .attr("fill", "#374151")
            .attr("font-size", 12)
            .text("Poverty rate (2023) (%)");

          scatterSvg
            .selectAll(".ylab")
            .data([0])
            .join("text")
            .attr("class", "ylab")
            .attr(
              "transform",
              `translate(${16},${scatter.margin.top + innerH / 2}) rotate(-90)`,
            )
            .attr("text-anchor", "middle")
            .attr("fill", "#374151")
            .attr("font-size", 12)
            .text("Unemployment rate (2023) (%)");

          const color = makeColorScale();

          const pts = scatter.g
            .selectAll("circle.pt")
            .data(fx, (d) => d.fips5)
            .join(
              (enter) =>
                enter
                  .append("circle")
                  .attr("class", "pt")
                  .attr("cx", (d) => scatter.x(d[xKey]))
                  .attr("cy", (d) => scatter.y(d[yKey]))
                  .attr("r", (d) => scatter.r(d.labor_force_2023 || 0))
                  .attr("fill", (d) => color(d.State))
                  .attr("stroke", "#111827")
                  .attr("stroke-opacity", 0.2)
                  .attr("stroke-width", 1)
                  .attr("opacity", 0.65)
                  .on("mousemove", (event, d) => showTooltip(event, d))
                  .on("mouseleave", hideTooltip)
                  .on("click", (event, d) => {
                    activeCountyFips = d.fips5;
                    brushedFips = new Set();
                    scatter.brushG.call(brush.move, null);
                    renderAll();
                  }),
              (update) =>
                update
                  .transition()
                  .duration(120)
                  .attr("cx", (d) => scatter.x(d[xKey]))
                  .attr("cy", (d) => scatter.y(d[yKey]))
                  .attr("r", (d) => scatter.r(d.labor_force_2023 || 0))
                  .attr("fill", (d) => color(d.State)),
              (exit) => exit.remove(),
            );

          const hasBrush = brushedFips.size > 0;
          const hasActive = !!activeCountyFips;
          const segKey = activeSegmentKey;

          pts.classed("dim", (d) => {
            if (hasBrush) return !brushedFips.has(d.fips5);
            if (hasActive) return d.fips5 !== activeCountyFips;
            if (segKey) return !segmentHighlightPredicate(d, segKey);
            return false;
          });

          pts
            .classed("active", (d) => hasActive && d.fips5 === activeCountyFips)
            .attr("stroke-opacity", (d) =>
              hasActive && d.fips5 === activeCountyFips ? 0.65 : 0.2,
            );

          scatter.brushG
            .attr(
              "transform",
              `translate(${scatter.margin.left},${scatter.margin.top})`,
            )
            .call(
              brush.extent([
                [0, 0],
                [innerW, innerH],
              ]),
            );

          scatter.brushG.lower();
        }

        function brushed(event) {
          if (!event.selection) {
            brushedFips = new Set();
            renderStacked();
            renderDetails();
            renderScatter();
            return;
          }

          activeCountyFips = null;
          const [[x0, y0], [x1, y1]] = event.selection;

          const xKey = "poverty_rate_2023";
          const yKey = "unemployment_rate_2023";
          const fx = filtered.filter(
            (d) => Number.isFinite(d[xKey]) && Number.isFinite(d[yKey]),
          );

          const selected = fx.filter((d) => {
            const cx = scatter.x(d[xKey]);
            const cy = scatter.y(d[yKey]);
            return x0 <= cx && cx <= x1 && y0 <= cy && cy <= y1;
          });

          brushedFips = new Set(selected.map((d) => d.fips5));
          renderStacked();
          renderDetails();
          renderScatter();
        }

        function renderStacked() {
          const { w, h } = getSvgSize(stackSvg, 360, 360);
          const innerW = w - stacked.margin.left - stacked.margin.right;
          const innerH = h - stacked.margin.top - stacked.margin.bottom;

          stacked.g.attr(
            "transform",
            `translate(${stacked.margin.left},${stacked.margin.top})`,
          );

          let rows = filtered;
          if (brushedFips.size > 0)
            rows = filtered.filter((d) => brushedFips.has(d.fips5));
          else if (activeCountyFips)
            rows = filtered.filter((d) => d.fips5 === activeCountyFips);

          function wavg(rows, key) {
            let num = 0,
              den = 0;
            for (const r of rows) {
              const ww = r.labor_force_2023 ?? NaN;
              const vv = r[key] ?? NaN;
              if (Number.isFinite(ww) && ww > 0 && Number.isFinite(vv)) {
                num += vv * ww;
                den += ww;
              }
            }
            if (den === 0) {
              const vals = rows.map((r) => +r[key]).filter(Number.isFinite);
              return vals.length ? d3.mean(vals) : NaN;
            }
            return num / den;
          }

          const comp = EDU.map((e) => ({
            key: e.key,
            label: e.label,
            value: wavg(rows, e.key),
          }));
          const total = d3.sum(comp, (d) => d.value);
          const segs = comp.map((d) => ({
            ...d,
            value: (d.value / total) * 100,
          }));

          let acc = 0;
          const stackedSegs = segs.map((d) => {
            const y0 = acc;
            acc += d.value;
            return { ...d, y0, y1: acc };
          });

          stacked.x.domain(["Education"]).range([0, innerW]);
          stacked.y.domain([0, 100]).range([innerH, 0]);

          const barX = stacked.x("Education");
          const barW = stacked.x.bandwidth();
          const colors = d3.schemeTableau10;

          const rects = stacked.g
            .selectAll("rect.seg")
            .data(stackedSegs, (d) => d.key)
            .join(
              (enter) =>
                enter
                  .append("rect")
                  .attr("class", "seg")
                  .attr("x", barX)
                  .attr("width", barW)
                  .attr("y", (d) => stacked.y(d.y1))
                  .attr("height", (d) =>
                    Math.max(0, stacked.y(d.y0) - stacked.y(d.y1)),
                  )
                  .attr("fill", (d, i) => colors[i % colors.length])
                  .attr("stroke", "#111827")
                  .attr("stroke-opacity", 0.15)
                  .attr("stroke-width", 1)
                  .on("click", (event, d) => {
                    activeSegmentKey =
                      activeSegmentKey === d.key ? null : d.key;
                    renderScatter();
                    renderStacked();
                  })
                  .on("mousemove", (event, d) => {
                    tooltip
                      .style("display", "block")
                      .style("left", event.clientX + "px")
                      .style("top", event.clientY + "px")
                      .html(`<div><strong>${d.label}</strong></div>
                     <div><span class="k">Share:</span> <span class="kv">${d.value.toFixed(1)}%</span></div>`);
                  })
                  .on("mouseleave", hideTooltip),
              (update) =>
                update
                  .transition()
                  .duration(120)
                  .attr("x", barX)
                  .attr("width", barW)
                  .attr("y", (d) => stacked.y(d.y1))
                  .attr("height", (d) =>
                    Math.max(0, stacked.y(d.y0) - stacked.y(d.y1)),
                  ),
              (exit) => exit.remove(),
            );

          rects.classed(
            "dim",
            (d) => activeSegmentKey && d.key !== activeSegmentKey,
          );

          stacked.g
            .selectAll("text.segLabel")
            .data(stackedSegs, (d) => d.key)
            .join("text")
            .attr("class", "segLabel")
            .attr("y", (d) => stacked.y((d.y0 + d.y1) / 2))
            .attr("dominant-baseline", "middle")
            .attr("fill", "#111827")
            .attr("font-size", 11)
            .attr("font-weight", 650)
            .text((d) => d.label)
            .attr("text-anchor", (d) => {
              const segPx = Math.abs(stacked.y(d.y0) - stacked.y(d.y1));
              return segPx < 18 ? "start" : "middle";
            })
            .attr("x", (d) => {
              const segPx = Math.abs(stacked.y(d.y0) - stacked.y(d.y1));
              return segPx < 18 ? barX + barW + 8 : barX + barW / 2;
            });

          stackSvg
            .selectAll(".yAxis")
            .data([0])
            .join("g")
            .attr("class", "axis yAxis")
            .attr(
              "transform",
              `translate(${stacked.margin.left - 8},${stacked.margin.top})`,
            )
            .call(
              d3
                .axisLeft(stacked.y)
                .ticks(5)
                .tickFormat((d) => d + "%"),
            );

          const st = Array.from(selectedStates).sort(d3.ascending);
          d3.select("#stackMeta").text(`States: ${st.join(", ")}`);
        }

        function segmentHighlightPredicate(d, segKey) {
          const vals = filtered
            .map((r) => +r[segKey])
            .filter(Number.isFinite)
            .sort(d3.ascending);
          if (!vals.length) return true;
          const med = d3.quantile(vals, 0.5);
          return +d[segKey] >= med;
        }

        function renderDetails() {
          const el = d3.select("#details");
          if (selectedStates.size === 0) {
            el.text("");
            return;
          }

          if (activeCountyFips) {
            const d = filtered.find((x) => x.fips5 === activeCountyFips);
            if (!d) {
              el.text("");
              return;
            }
            el.html(
              `<strong>${escapeHtml(d["Area name"])}</strong> (${d.State})<br>` +
                `Poverty: ${fmt1(d.poverty_rate_2023)}%  |  Unemp: ${fmt1(d.unemployment_rate_2023)}%<br>` +
                `Median Income: $${fmt0(d.median_household_income_2022)}`,
            );
            return;
          }

          if (brushedFips.size > 0) {
            el.text(`brushed: ${brushedFips.size.toLocaleString()} counties`);
            return;
          }

          el.text("");
        }

        function showTooltip(event, d) {
          tooltip
            .style("display", "block")
            .style("left", event.clientX + "px")
            .style("top", event.clientY + "px")
            .html(
              `<div><strong>${escapeHtml(d["Area name"])}</strong> <span class="k">(${d.State})</span></div>` +
                `<div><span class="k">Poverty:</span> <span class="kv">${fmt1(d.poverty_rate_2023)}%</span></div>` +
                `<div><span class="k">Unemployment:</span> <span class="kv">${fmt1(d.unemployment_rate_2023)}%</span></div>` +
                `<div><span class="k">Median Income:</span> <span class="kv">$${fmt0(d.median_household_income_2022)}</span></div>`,
            );
        }

        function hideTooltip() {
          tooltip.style("display", "none");
        }
        function fmt0(x) {
          return Number.isFinite(+x) ? d3.format(",.0f")(x) : "—";
        }
        function fmt1(x) {
          return Number.isFinite(+x) ? d3.format(".1f")(x) : "—";
        }
        function escapeHtml(s) {
          return String(s)
            .replaceAll("&", "&amp;")
            .replaceAll("<", "&lt;")
            .replaceAll(">", "&gt;")
            .replaceAll('"', "&quot;")
            .replaceAll("'", "&#039;");
        }
      })();
    </script>
  </body>
</html>
